# Compiled Code Simulator

- A compiled code simulator for digital circuits is a software tool that allows you to simulate and test a digital circuit design, typically described using a hardware description language (HDL) such as Verilog or VHDL

- For the sake of this implementation, we have created our own hardware description language similar to NGSPICE, sufficient to describe any combinational digital circuit. Refer the bottom code snippet with examples on how to describe circuits

```
* this is a comment

* inp <nodes seperated by spaces> denotes input nodes to circuit

inp n1 n2 n4 n6 x1 x2 x3 x4 x5 x6


* outp <nodes seperated by spaces> denotes output nodes to circuit

outp n3 n5 n7 o1 o2 o3


and n1 n2 n3

* denotes and gate with inputs n1 and n2, output as n3


or n3 n4 n5 

* denotes or gate with inputs n3 and n4, output as n5 


inv n6 n7

* denotes inverter with input n6 and output n7

nand x1 x2 o1

* denotes nand gate with inputs x1 and x2, output as o1 

nor x3 x4 o2

* denotes nor gate with inputs x3 and x4, output as o2 

xor x5 x6 03

* denotes xor gate with inputs x5 and x6, output as o3 

```

## How is this useful in VLSI 

- A logic simulator is a software tool that is used to simulate the behavior of digital circuits, they are used to verify the correctness of digital circuits before they are physically implemented.
- It allows one to test a digital circuit design against a set of test vectors, which are input signals that are used to exercise the circuit and study its outputs for correctness.
- Using a logic simulator, one can detect and fix design errors before the circuit is fabricated, saving both time and money.
- One can analyze its performance and identify potential bottlenecks or areas for improvement.

## How to setup Python environment

- make virtual environment for python : `python3 -m venv ccsim`
- activate virtual environment: `source ccsim/bin/activate`
- set up libraries required for ccsim's algorithm: `pip install -r requirements.txt`

- we are making use of automan to compare the performance of the following
- 1. numba njit accelerated implementation of compiled code simulator (`compiled_code_sim_numba.py`)
- 2. regular pythonic implementation of compiled code simulator (`compiled_code_sim.py`)


## Usage of `compiled_code_sim.py` and `compiled_code_sim_numba.py`

```bash
python3 ccsim_algorithm.py --b (optional) -c circuitfile -t truthtablefile
```
- `-t/--truthtable` is the filename to store the truth table of the logic simulated, it will be stored in `truthtablefile.csv`
- `-c/--circuit` is the input filename with description of digital circuit, it should be stored in `circuitfile.txt`


## Some Examples

`python3 compiled_code_sim.py -c benchmarks/fulladder  -t fulladder --b`

### Outputs Obtained


```
7.574600203952286e-05
```

### `fulladder.csv`


```

A,B,C,Sum,Cout
0,0,0,0,0
0,0,1,1,0
0,1,0,1,0
0,1,1,0,1
1,0,0,1,0
1,0,1,0,1
1,1,0,0,1
1,1,1,1,1

```

## Benchmarking using Automan
- to run the automan scripts which benchmarks for given values of maze size run `python3 automate.py`
- the plot generated by automan can be found in `/manuscripts/figures/timing.pdf`
- the outputs, truthtables generated can be found in `outputs/CCSimulator` for pythonic, and in `outputs/CCSimulatorNumba` for numba accelerated

### Results Obtained on Benchmarking

- The numba accelerated implementation is atleast an order of magnitude $10^1$ faster than the regular pythonic implementation of the logic simulator as we can see for various common circuit benchmarks in `benchmarks/` 