# Dijkstra's Algorithm


## How is this useful in VLSI 

- VLSI circuits can be modelled as Directed Acyclic Graphs with the logic gates/transistors as nodes and wires/interconnects as weighted edges
- These wires have a cost metric (length, propogation delay) which is non negative, hence Dijkstra's Algorithm is applicable here.
- In VLSI CAD design, the placement of components on a chip is critical to the overall performance and functionality of the design. The goal is to place the components in a way that minimizes the total distance that signals need to travel between them. This can be achieved by using Dijkstra's algorithm to find the shortest path between each pair of components and then using this information to optimize the placement of the components on the chip
- Dijkstra's algorithm can also be used to optimize the routing of connections between components on a chip. By finding the shortest path between each pair of components, this can be used to minimize the length of the connections and reduce the overall complexity of the routing

## How to setup Python environment

- make virtual environment for python : `python3 -m venv dijkstra`
- activate virtual environment: `source dijkstra/bin/activate`
- set up libraries required for dijkstra's algorithm: `pip install -r requirements.txt`

- we are making use of automan to compare the performance of the following
- 1. numba njit accelerated dijkstra's algorithm (`dijkstra_numba_accelerated`)
- 2. regular pythonic dijkstra's algorithm (`dijkstra_pythonic`)
- 3. networkx implementation of dijkstra's algorithm (`dijkstra_nx`), uses (`nx.dijkstra_path()`)


## Usage of `dijkstra.py`

```bash
python3 dijkstra_algorithm.py --b (optional) [--c -n size -p prob -w1 minw1 -w2 minw2 ]/[--f] -m fileloc -s start_node -e end_node   
```
- if `--c` flag is passed this script directly creates a benchmark of size n and probability p using the `gnp_random_graph()` which generates erdos renyi graphs which are DAGs (Directed Acyclic Graph)

- $n$ here denotes the number of nodes in the graph

- $p$ here denotes the probability of a particular pair of nodes $i, j$ to have an edge between them, and is independent of $i$ and $j$.
- the graph is stored as numpy arrays of nodes and edgelist in `fileloc.npz` 

- if `--f` flag is passed then we need to specify the graph we are feeding to it by passing it filename as `-m fileloc` if our benchmark maze is stored in `fileloc.npz` 

- if `--b` flag is used then benchmarking will be done using `time.perf_counter()` and the time taken by each of the methods will be printed on three lines in the order (numba, python, networkx), if this flag is not specified, the script will produce two `.pdf` files each containing the graph generated by the script/passed to the script (in `fileloc.pdf`) and one with shortest path highlighted (in `fileloc_shortest_path.pdf`) and also print the shortest path obtained all three methods one by one


## Some Examples

`python3 dijkstra.py --c -n 10 -p 0.3 -w1 5 -w2 15 -s 0 -e 9 -m benchmark`

### Outputs Obtained

```
[0, 7, 9]
[0, 7, 9]
[0, 7, 9]
```

#### `benchmark.pdf`
![image](https://user-images.githubusercontent.com/46604893/228672986-24113839-3e2c-4465-8584-69f212760ac7.png)

#### `benchmark_shortest_path.pdf`
![image](https://user-images.githubusercontent.com/46604893/228672930-59e1cc60-0980-4216-8d94-1c94465e94b3.png)


`python3 dijkstra.py --c -n 10 -p 0.3 -w1 5 -w2 15 -s 0 -e 9 -m benchmark --b`

### Outputs Obtained

```
0.00016592199972365052
0.0001015819998428924
3.8099000448710285e-05
```

## Benchmarking using Automan
- to run the automan scripts which benchmarks for given values of maze size run `python3 automate.py`
- the plot generated by automan can be found in `/manuscripts/figures/Dijkstra`

### Results Obtained on Benchmarking
> Values of maze size chosen were $n \in \{10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 150, 175\}$ 

![image](https://user-images.githubusercontent.com/46604893/228673076-bad51d7f-f69f-4e50-b267-59c83e7e5256.png)

![image](https://user-images.githubusercontent.com/46604893/228673143-a8c2bd5c-df63-41b6-8d94-9744cbd2d608.png)


- we see that the performance of the numba accelerated dijkstra produces a small speedup $2 \le x \le 10$ for small graphs and as the number of nodes increase the three methods nearly converge in the same time 
